<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spark RDD详解</title>
      <link href="/2019/04/26/Spark-RDD%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/04/26/Spark-RDD%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;<strong>RDD(Resilient Distributed Dateset)，弹性分布式数据集。</strong></p><p>&emsp;&emsp;RDD是Spark的最基本抽象,是对分布式内存的抽象使用，实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD是Spark最核心的东西，它表示已被分区，不可变的并能够被并行操作的数据集合，不同的数据集格式对应不同的RDD实现。RDD必须是可序列化的。RDD可以cache到内存中，每次对RDD数据集的操作之后的结果，都可以存放到内存中，下一个操作可以直接从内存中输入，省去了MapReduce大量的磁盘IO操作。这对于迭代运算比较常见的机器学习算法, 交互式数据挖掘来说，效率提升非常大。</p><a id="more"></a><p>&emsp;&emsp;RDD 最适合那种在数据集上的所有元素都执行相同操作的批处理式应用。在这种情况下， RDD 只需记录血统中每个转换就能还原丢失的数据分区，而无需记录大量的数据操作日志。所以 RDD 不适合那些需要异步、细粒度更新状态的应用 ，比如 Web 应用的存储系统，或增量式的 Web 爬虫等。对于这些应用，使用具有事务更新日志和数据检查点的数据库系统更为高效。</p><h3 id="五大特性"><a href="#五大特性" class="headerlink" title="五大特性"></a>五大特性</h3><ol><li>RDD是由一系列的partition组成的。</li><li>函数是作用在每一个partition上的。</li><li>RDD之间有一系列的依赖关系。</li><li>分区器是作用在K,V格式的RDD上。</li><li>RDD提供一系列最佳的计算位置。</li></ol><h3 id="理解图"><a href="#理解图" class="headerlink" title="理解图"></a>理解图</h3><p><img src="https://i.loli.net/2019/04/26/5cc2b1e977baf.png" alt></p><h3 id="血统（Lineage）"><a href="#血统（Lineage）" class="headerlink" title="血统（Lineage）"></a>血统（Lineage）</h3><p><img src="https://i.loli.net/2019/04/26/5cc2b47da5521.png" alt></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>textFile</strong>方法底层封装的是MR读取文件的方式，在读取文件之前先split，默认split大小是一个block大小。</p></li><li><p>RDD实际上是<strong>不存数据</strong>的。</p></li><li><p><strong>K,V格式</strong>的RDD是指RDD内的数据是<strong>二元组对象</strong>。</p></li><li><p>如何体现RDD的<strong>弹性</strong>（<strong>容错</strong>）？</p><p>partition数量、大小没有限制。</p><p>RDD之间有依赖关系，可以基于上一个RDD重新计算。</p></li><li><p>如何体现RDD的<strong>分布式</strong>？</p><p>RDD是由Partition组成的，而partition分布在不同的节点上。</p></li><li><p>RDD提供了计算最佳位置，体现了数据本地化，符合大数据中“<strong>计算移动数据不移动</strong>”的理念。</p></li><li><p>来源：一种是从<strong>持久存储获取数据</strong>，一种是从<strong>其他RDD生成</strong>。</p></li></ol><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>&emsp;&emsp;目前有两种类型的基础RDD：<strong>并行集合</strong>（Parallelized Collections）：接收一个已经存在的Scala集合，然后进行各种并行计算。 <strong>Hadoop数据集</strong>（Hadoop Datasets）：在一个文件的每条记录上运行函数。只要文件系统是HDFS，或者hadoop支持的任意存储系统即可。这两种类型的RDD都可以通过相同的方式进行操作，从而获得子RDD等一系列拓展，形成<strong>lineage血统关系图</strong>。</p><ol><li><p><strong>并行化集合</strong></p><p>并行化集合是通过调用SparkContext的parallelize方法，在一个已经存在的Scala集合上创建的（一个Seq对象）。集合的对象将会被拷贝，创建出一个可以被并行操作的分布式数据集。例如，下面的解释器输出，演示了如何从一个数组创建一个并行集合。</p><p>例如：val rdd = sc.parallelize(Array(1 to 10)) 根据能启动的executor的数量来进行切分多个slice，每一个slice启动一个Task来进行处理。</p><p>val rdd = sc.parallelize(Array(1 to 10), 5) 指定了partition的数量。</p></li><li><p><strong>Hadoop数据集</strong></p><p>Spark可以将任何Hadoop所支持的存储资源转化成RDD,如本地文件（需要网络文件系统，所有的节点都必须能访问到）、HDFS、Cassandra、HBase、Amazon S3等，Spark支持文本文件、SequenceFiles和任何Hadoop InputFormat格式。</p><ul><li><p>使用<strong>textFile()</strong>方法可以将本地文件或HDFS文件转换成RDD，支持整个文件目录读取，文件可以是文本或者压缩文件(如gzip等，自动执行解压缩并加载数据)。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">"file:///root/access_log/access_log\*.filter"</span>);</span><br><span class="line"><span class="keyword">val</span> rdd2=rdd1.map(_.split(<span class="string">"t"</span>)).filter(_.length==<span class="number">6</span>)；</span><br><span class="line">rdd2.count()；</span><br></pre></td></tr></table></figure><p>textFile()可选第二个参数slice，默认情况下为每一个block分配一个slice。用户也可以通过slice指定更多的分片，但不能使用少于HDFS block的分片数。</p></li><li><p>使用<strong>wholeTextFiles()</strong>读取目录里面的小文件，返回（用户名、内容）对.</p></li><li><p>使用<strong>sequenceFile[K,V]()</strong>方法可以将SequenceFile转换成RDD。SequenceFile文件是Hadoop用来存储二进制形式的key-value对而设计的一种平面文件(Flat File)。</p></li><li><p>使用<strong>SparkContext.hadoopRDD</strong>方法可以将其他任何Hadoop输入类型转化成RDD使用方法。一般来说，HadoopRDD中每一个HDFS block都成为一个RDD分区。</p><p>此外，通过Transformation可以将HadoopRDD等转换成FilterRDD(依赖一个父RDD产生）和JoinedRDD（依赖所有父RDD）等。</p></li></ul></li></ol><h3 id="转换与操作"><a href="#转换与操作" class="headerlink" title="转换与操作"></a>转换与操作</h3><p>&emsp;&emsp;对于RDD可以有两种计算方式：<strong>转换</strong>（返回值还是一个RDD）与<strong>操作</strong>（返回值不是一个RDD）</p><ul><li><p><strong>转换(Transformations)</strong> (如：map, filter, groupBy, join等)，Transformations操作是Lazy的，也就是说从一个RDD转换生成另一个RDD的操作不是马上执行，Spark在遇到Transformations操作时只会记录需要这样的操作，并不会去执行，需要等到有Actions操作的时候才会真正启动计算过程进行计算。</p></li><li><p><strong>操作(Actions)</strong> (如：count, collect, save等)，Actions操作会返回结果或把RDD数据写到存储系统中。Actions是<strong>触发Spark启动</strong>计算的动因。</p></li></ul><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>&emsp;&emsp;RDD之间存在一系列的<strong>依赖关系</strong>，依赖关系分为<strong>窄依赖</strong>和<strong>宽依赖</strong>。</p><ul><li><strong>窄依赖</strong>：父 RDD 和子 RDD partition 之间的关系是一对一的。或者父 RDD 一个partition 只对应一个子 RDD 的 partition 情况下的父 RDD 和子 RDD partition 关系是多对一的。<strong>不会有 shuffle 的产生</strong>。</li><li><strong>宽依赖</strong>：父RDD与子RDD partition之间的关系是一对多。<strong>会有shuffle的产生</strong>。</li></ul><p><img src="https://i.loli.net/2019/04/26/5cc2cdbc506e3.gif" alt></p><h3 id="RDD缓存"><a href="#RDD缓存" class="headerlink" title="RDD缓存"></a>RDD缓存</h3><p>&emsp;&emsp;RDD的持久化方式有三种：<strong>cache</strong>、<strong>persist</strong>、<strong>checkpoint</strong>。持久化的单位都是<strong>partition</strong>。其中，cache和persisit都是<strong>懒执行</strong>的，必须有一个action算子触发执行。<strong>checkpoint</strong>算子不仅能将RDD持久化到磁盘，还能切断RDD之间的依赖关系。</p><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>默认将RDD持久化到内存中。cache()是persist()的特例。</p><h4 id="persist"><a href="#persist" class="headerlink" title="persist"></a>persist</h4><p>可以指定持久化的级别。最常用的就是<strong>MEMORY_ONLY</strong>和<strong>MEMORY_AND_DISK</strong>.”<strong>_2</strong>“表示有副本数。具体的持久化级别如下：</p><p><img src="https://i.loli.net/2019/04/26/5cc2d280903e7.png" alt></p><h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>将RDD持久化到磁盘，还可以切断RDD之间的依赖关系。执行原理：</p><ol><li>当 RDD 的 job 执行完毕后，会从 finalRDD 从后往前回溯。</li><li>当回溯到某一个 RDD 调用了 checkpoint 方法，会对当前的RDD 做一个标记。</li><li>Spark 框架会自动启动一个新的 job，重新计算这个 RDD 的数据，将数据持久化到 HDFS 上。</li></ol><p>注意事项：</p><ul><li>cache 和 persist 都是懒执行，必须有一个 action 类算子触发执行。</li><li>cache 和 persist 算子的返回值可以赋值给一个变量，在其他 job 中直接使用这个变量就是使用持久化的数据了。持久化的单位是 partition。</li><li>cache 和 persist 算子后不能立即紧跟 action 算子。</li><li>对 RDD 执行 checkpoint 之前，最好对这个 RDD 先执行cache，这样新启动的 job 只需要将内存中的数据拷贝到 HDFS上就可以，省去了重新计算这一步。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> RDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark编程模型</title>
      <link href="/2019/04/26/Spark%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/04/26/Spark%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;Spark和MapReduce都是<strong>分布式计算框架</strong>，但是Spark处理数据的能力是MR的十倍以上，不仅仅是因为Spark基于<strong>内存</strong>，MR基于<strong>HDFS</strong>，还有就是Spark通过<strong>DAG有向无环图</strong>来切分任务的执行先后顺序。<br><a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>应用程序（Application）</strong>： 基于Spark的用户程序，包含了一个Driver Program 和集群中多个的Executor；</li><li><strong>驱动程序（Driver Program）</strong>：运行Application的main()函数并且创建SparkContext，通常用SparkContext代表Driver Program；</li><li><strong>执行单元（Executor）</strong>： 是为某Application运行在Worker Node上的一个进程，该进程负责运行Task，并且负责将数据存在内存或者磁盘上，每个Application都有各自独立的Executors；</li><li><strong>集群管理程序（Cluster Manager）：</strong> 在集群上获取资源的外部服务(例如：Standalone、Mesos或Yarn)；</li><li><strong>操作（Operation）</strong>：作用于RDD的各种操作分为Transformation和Action；</li></ul><h2 id="任务执行原理"><a href="#任务执行原理" class="headerlink" title="任务执行原理"></a>任务执行原理</h2><p>&emsp;&emsp;<strong>Driver</strong>和<strong>Worker</strong>是启动在节点上的进程，运行在JVM中的进程。</p><ul><li><strong>Driver</strong> 与集群节点之间有频繁的通信。</li><li><strong>Driver</strong> 负责任务(tasks)的分发和结果的回收、任务的调度。如果 task的计算结果非常大就不要回收了，会造成 oom。</li><li><strong>Worker</strong> 是 Standalone 资源调度框架里面资源管理的从节点，也是JVM 进程。</li><li><strong>Master</strong> 是 Standalone 资源调度框架里面资源管理的主节点，也是JVM 进程。</li></ul><p><img src="https://i.loli.net/2019/04/26/5cc2b5071bfa6.png" alt></p><h2 id="模型组成"><a href="#模型组成" class="headerlink" title="模型组成"></a>模型组成</h2><p>&emsp;&emsp;Spark应用程序可分为两部分：<strong>Driver部分</strong>和<strong>Executor部分</strong>。</p><p><img src="https://i.loli.net/2019/04/26/5cc2b6e9d3790.jpg" alt></p><ol><li><p>Driver部分</p><p><strong>Driver部分</strong>主要是对<strong>SparkContext</strong>进行配置、初始化以及关闭。初始化SparkContext是为了构建Spark应用程序的运行环境，在初始化SparkContext，要先导入一些Spark的类和隐式转换；在Executor部分运行完毕后，需要将SparkContext关闭。</p></li><li><p>Executor部分</p><p><strong>Executor部分</strong>是对数据的处理。</p></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="原生数据"><a href="#原生数据" class="headerlink" title="原生数据"></a>原生数据</h3><p>&emsp;&emsp;包括原生的输入数据和输出数据：</p><ol><li><strong>输入数据</strong>，Spark目前提供了两种:<ul><li><strong>Scala集合数据集</strong>：如Array(1,2,3,4,5)，Spark使用<strong>parallelize</strong>方法转换成RDD</li><li><strong>Hadoop数据集</strong>：Spark支持存储在hadoop上的文件和hadoop支持的其他文件系统，如本地文件、HBase、SequenceFile和Hadoop的输入格式。例如Spark使用<strong>textFile</strong>方法可以将本地文件或HDFS文件转换成RDD</li></ul></li><li><strong>输出数据</strong>，Spark除了支持上述两种外，还支持scala标量：<ul><li>生成Scala标量数据，如count（返回RDD中元素的个数）、reduce、fold/aggregate；返回几个标量，如take（返回前几个元素）。</li><li>生成Scala集合数据集，如collect（把RDD中的所有元素倒入 Scala集合类型）、lookup（查找对应key的所有值）。</li><li>生成hadoop数据集，如saveAsTextFile、saveAsSequenceFile</li></ul></li></ol><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><p>&emsp;&emsp;RDD提供了四种算子：</p><ul><li><strong>输入算子</strong>：将原生数据转换成RDD，如parallelize、txtFile等。</li><li><strong>转换算子</strong>：最主要的算子，是Spark生成DAG图的对象，转换算子并不立即执行，在触发行动算子后再提交给driver处理，生成DAG图 –&gt;  Stage –&gt; Task  –&gt; Worker执行。</li><li><strong>缓存算子</strong>：对于要多次使用的RDD，可以缓冲加快运行速度，对重要数据可以采用多备份缓存。</li><li><strong>行动算子</strong>：将运算结果RDD转换成原生数据，如count、reduce、collect、saveAsTextFile等。</li></ul><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>&emsp;&emsp;在Spark运行时，一个函数传递给RDD内的patition操作时，该函数所用到的变量在每个运算节点上都复制并维护了一份，并且各个节点之间不会相互影响。但是在Spark Application中，可能需要共享一些变量，提供Task或驱动程序使用。Spark提供了两种共享变量：</p><ol><li><p><strong>广播变量（Broadcast Variables）</strong>：可以缓存到各个节点的共享变量，通常为只读</p><ul><li><p>广播变量缓存到各个节点的内存中，而不是每个 Task。</p></li><li><p>广播变量被创建后，能在集群中运行的任何函数调用。</p></li><li><p>广播变量是只读的，不能在被广播后修改。</p></li><li><p>对于大数据集的广播， Spark 尝试使用高效的广播算法来降低通信成本。</p></li><li><p>使用方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> broadcastVar ==sc.broadcast(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>累加器</strong>：只支持加法操作的变量，可以实现计数器和变量求和。用户可以调用SparkContext.accumulator(v)创建一个初始值为v的累加器，而运行在集群上的Task可以使用“+=”操作，但这些任务却不能读取；只有驱动程序才能获取累加器的值。</p><ul><li><p>使用方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> accum = sc.accumulator(<span class="number">0</span>)；</span><br><span class="line">sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)).foreach(x =&gt; accum  + = x)；</span><br><span class="line">accum.value；</span><br><span class="line"><span class="keyword">val</span> num=sc.parallelize(<span class="number">1</span> to <span class="number">100</span>)；</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark生态圈</title>
      <link href="/2019/04/26/Spark%E7%94%9F%E6%80%81%E5%9C%88/"/>
      <url>/2019/04/26/Spark%E7%94%9F%E6%80%81%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><p>&emsp;&emsp;<strong>Spark生态圈</strong>也被称为<strong>BDAS</strong>（伯克利数据分析栈），力图在<strong>算法</strong>（Algorithms）、<strong>机器</strong>（Machines）、<strong>人</strong>（People）之间通过大规模集成来展现大数据应用的一个平台。该生态圈已经涉及到了机器学习、数据挖掘、数据库、信息检索、自然语言处理和语音识别等多个领域。</p><p>&emsp;&emsp;Spark生态圈以<strong>Spark Core</strong>为核心，从<strong>HDFS</strong>、<strong>Amazon S3</strong>和<strong>HBase</strong>等持久层读取数据，以<strong>YARN</strong>和<strong>Standalone</strong>等作为资源管理器调度Job完成Spark应用程序的计算。这些应用程序可以来自不同的组件，如<strong>Spark Shell/Spark Submit</strong>的批处理、<strong>Spark Streaming</strong>的实时处理、<strong>Spark SQL</strong>的即席查询、<strong>BlinkDB</strong>的权衡查询、<strong>MLlib/MLbase</strong>的机器学习、<strong>GraphX</strong>的图处理和<strong>SparkR</strong>的数学计算等等。<br><a id="more"></a><br><img src="https://i.loli.net/2019/04/26/5cc27919e6cde.jpg" alt></p><h2 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h2><ol><li>提供了<strong>有向无环图</strong>（DAG）的分布式并行计算框架，并提供<strong>Cache机制</strong>来支持多次迭代计算或者数据共享，大大减少迭代计算之间读取数据局的开销，这对于需要进行多次迭代的数据挖掘和分析性能有很大提升。</li><li>在Spark中引入了<strong>RDD (Resilient Distributed Dataset)</strong> 的抽象，它是分布在一组节点中的只读对象集合，这些集合是弹性的，如果数据集一部分丢失，则可以根据“<strong>血统</strong>”对它们进行重建，保证了数据的高容错性。</li><li><strong>移动计算而非移动数据</strong>，RDD Partition可以就近读取分布式文件系统中的数据块到各个节点内存中进行计算。</li><li>使用<strong>多线程池模型</strong>来减少task启动开稍。</li><li>采用容错的、高可伸缩性的<strong>akka</strong>作为通讯框架。</li></ol><h2 id="SparkStreaming"><a href="#SparkStreaming" class="headerlink" title="SparkStreaming"></a>SparkStreaming</h2><p>&emsp;&emsp;<strong>SparkStreaming</strong>是一个对实时数据流进行高通量、容错处理的<strong>流式处理系统</strong>，可以对多种数据源（如Kdfka、Flume、Twitter、Zero和TCP 套接字）进行各种复杂算子操作，并将结果保存到外部文件系统、数据库或应用到实时仪表盘。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><h4 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h4><p>&emsp;&emsp;SparkStreaming会将计算分解成一系列短小的<strong>批处理作业</strong>。这里批处理的引擎是<strong>Spark Core</strong>，SparkStreaming的数据数据会按照<strong>batch size</strong>分成一段一段的数据，每一段数据都会转换成<strong>RDD</strong>，这样就将SparkStreaming中对DStream的Transformation操作变成了针对Spark中对RDD的Transformation操作，将RDD经过操作变成的中间结果保存到<strong>内存</strong>中。</p><h4 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h4><p>&emsp;&emsp;对于一个流式计算来说，<strong>容错性</strong>是至关重要的。RDD是一个不可变的分布式可重算的数据集，它记录着操作继承关系（<strong>lineage</strong>），因此，任意一个RDD的分区出错，都可以利用原始数据重新计算。每一个RDD由多个<strong>partition</strong>组成，RDD之间通过lineage相连，多个RDD构成了<strong>血统</strong>，所以当数据是来源于<strong>HDFS</strong>（多备份）或<strong>网络的数据流</strong>（SparkStreaming会将网络输入数据的每一个数据流拷贝两份到其他机器）这种能保证容错性的数据源时，RDD的任意partition出错，都可以并行的在其他机器上将缺失的Partition计算出来。这个容错恢复方式比连续计算模型（Storm）的<strong>效率更高</strong>。</p><h4 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h4><p>&emsp;&emsp;目前版本的Spark Streaming，其最小的<strong>Batch Size</strong>的选取在<strong>0.5~2秒</strong>之间（Storm最小延迟是100ms左右），它是一种<strong>准实时</strong>的流式处理框架。</p><h4 id="扩展性与吞吐量"><a href="#扩展性与吞吐量" class="headerlink" title="扩展性与吞吐量"></a>扩展性与吞吐量</h4><p>&emsp;&emsp;Spark目前在EC2上已能够线性扩展到<strong>100</strong>个节点（每个节点4Core），可以以数秒的延迟处理<strong>6GB/s</strong>的数据量（60M records/s），其吞吐量也比流行的Storm高<strong>2～5</strong>倍。</p><h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><h3 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h3><p>&emsp;&emsp;众所周知，Hive可以将SQL编译成可扩展的MapReduce作业，为了能将Hive和Spark整合，<strong>Shark</strong>应运而生。Shark就是<strong>Hive on Spark</strong>，本质上是通过Hive的HQL解析，把HQL翻译成Spark上的RDD操作，然后通过Hive的metadata获取数据库里的表信息，实际HDFS上的数据和文件，会由Shark获取并放到Spark上运算。Shark的最大特性就是<strong>快</strong>和<strong>与Hive的完全兼容</strong>，且可以在shell模式下使用<strong>rdd2sql()</strong>这样的API，把HQL得到的结果集，继续在scala环境下运算，支持自己编写简单的机器学习或简单分析处理函数，对HQL结果进一步分析计算。</p><p>&emsp;&emsp;<strong>Shark</strong>就是<strong>Spark SQL</strong>的前身，Shark更多是对Hive的改造，替换了Hive的物理执行引擎，因此会有一个很快的速度。然而，不容忽视的是，Shark继承了大量的Hive代码，因此给优化和维护带来了大量的麻烦。随着性能优化和先进分析整合的进一步加深，基于MapReduce设计的部分无疑成为了整个项目的瓶颈。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>引入了新的RDD类型<strong>SchemaRDD</strong>，可以象传统数据库定义表一样来定义SchemaRDD，SchemaRDD由定义了列数据类型的行对象构成。SchemaRDD可以从RDD转换过来，也可以从Parquet文件读入，也可以使用HiveQL从Hive中获取。</li><li>内嵌了<strong>Catalyst查询优化框架</strong>，在把SQL解析成逻辑执行计划之后，利用Catalyst包里的一些类和接口，执行了一些简单的执行计划优化，最后变成RDD的计算。</li><li>在应用程序中可以混合使用<strong>不同来源的数据</strong>，如可以将来自HiveQL的数据和来自SQL的数据进行Join操作。</li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li><strong>内存列存储（In-Memory Columnar Storage）</strong> sparkSQL的表数据在内存中存储不是采用原生态的JVM对象存储方式，而是采用内存列存储；</li><li><strong>字节码生成技术（Bytecode Generation）</strong> Spark1.1.0在Catalyst模块的expressions增加了codegen模块，使用动态字节码生成技术，对匹配的表达式采用特定的代码动态编译。另外对SQL表达式都作了CG优化， CG优化的实现主要还是依靠Scala2.10的运行时放射机制（runtime reflection）；</li><li><strong>Scala代码优化</strong> SparkSQL在使用Scala编写代码的时候，尽量避免低效的、容易GC的代码；尽管增加了编写代码的难度，但对于用户来说接口统一。</li></ol><h2 id="BlinkDB"><a href="#BlinkDB" class="headerlink" title="BlinkDB"></a>BlinkDB</h2><p>&emsp;&emsp;<strong>BlinkDB</strong> 是一个用于在海量数据上运行<strong>交互式 SQL 查询</strong>的大规模并行查询引擎，它允许用户通过<strong>权衡数据精度</strong>来提升查询响应时间，其数据的精度被控制在允许的误差范围内。为了达到这个目标，BlinkDB 使用两个核心思想:</p><ul><li><p>一个<strong>自适应优化框架</strong>，从原始数据随着时间的推移建立并维护一组多维样本；</p></li><li><p>一个<strong>动态样本选择策略</strong>，选择一个适当大小的示例基于查询的准确性和（或）响应时间需求。</p></li></ul><p>&emsp;&emsp;和传统关系型数据库不同，BlinkDB是一个很有意思的交互式查询系统，就像一个跷跷板，用户需要在查询精度和查询时间上做一权衡；如果用户想更快地获取查询结果，那么将牺牲查询结果的精度；同样的，用户如果想获取更高精度的查询结果，就需要牺牲查询响应时间。用户可以在查询的时候定义一个失误边界。</p><h2 id="MLBase-MLlib"><a href="#MLBase-MLlib" class="headerlink" title="MLBase/MLlib"></a>MLBase/MLlib</h2><p>&emsp;&emsp;<strong>MLBase</strong>是Spark生态圈的一部分专注于机器学习，让机器学习的门槛更低，让一些可能并不了解机器学习的用户也能方便地使用MLbase。MLBase分为四部分：MLlib、MLI、ML Optimizer和MLRuntime。</p><ul><li><p><strong>ML Optimizer</strong>会选择它认为最适合的已经在内部实现好了的机器学习算法和相关参数，来处理用户输入的数据，并返回模型或别的帮助分析的结果；</p></li><li><p><strong>MLI</strong> 是一个进行特征抽取和高级ML编程抽象的算法实现的API或平台；</p></li><li><p><strong>MLlib</strong>是Spark实现一些常见的机器学习算法和实用程序，包括分类、回归、聚类、协同过滤、降维以及底层优化，该算法可以进行可扩充； </p></li><li><strong>MLRuntime</strong> 基于Spark计算框架，将Spark的分布式计算应用到机器学习领域。</li></ul><h2 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h2><p>&emsp;&emsp;<strong>GraphX</strong>是Spark中用于<strong>图</strong>(e.g., Web-Graphs and Social Networks)和<strong>图并行计算</strong>(e.g., PageRank and Collaborative Filtering)的API,可以认为是GraphLab(C++)和Pregel(C++)在Spark(Scala)上的重写及优化，跟其他分布式图计算框架相比，GraphX最大的贡献是，在Spark之上提供<strong>一栈式数据解决方案</strong>，可以方便且高效地完成图计算的一整套流水作业。GraphX最先是伯克利AMPLAB的一个分布式图计算框架项目，后来整合到Spark中成为一个核心组件。</p><h2 id="SparkR"><a href="#SparkR" class="headerlink" title="SparkR"></a>SparkR</h2><p>&emsp;&emsp;<strong>SparkR</strong>是AMPLab发布的一个R开发包，使得R摆脱单机运行的命运，可以作为Spark的job运行在集群上，极大得扩展了R的数据处理能力。</p><p>&emsp;&emsp;<strong>SparkR</strong>的几个特性：</p><ol><li>提供了Spark中弹性分布式数据集（RDD）的API，用户可以在集群上通过R shell交互性的运行Spark job。</li><li>支持<strong>序化闭包</strong>功能，可以将用户定义函数中所引用到的变量自动序化发送到集群中其他的机器上。</li><li>SparkR还可以很容易地调用R开发包，只需要在集群上执行操作前用includePackage读取R开发包就可以了，当然集群上要安装R开发包。</li></ol><h2 id="Tachyon"><a href="#Tachyon" class="headerlink" title="Tachyon"></a>Tachyon</h2><p>&emsp;&emsp;<strong>Tachyon</strong>是一个<strong>高容错的分布式文件系统</strong>，允许文件以内存的速度在集群框架中进行可靠的共享，就像Spark和 MapReduce那样。通过利用信息继承，内存侵入，Tachyon获得了高性能。Tachyon工作集文件缓存在<strong>内存</strong>中，并且让不同的 Jobs/Queries以及框架都能内存的速度来访问缓存文件”。因此，Tachyon可以减少那些需要经常使用的数据集通过访问磁盘来获得的次数。Tachyon兼容Hadoop，现有的Spark和MR程序不需要任何修改而运行。</p><h2 id="生态圈应用"><a href="#生态圈应用" class="headerlink" title="生态圈应用"></a>生态圈应用</h2><p>&emsp;&emsp;Spark生态圈以Spark为核心、以RDD为基础，打造了一个基于内存计算的大数据平台，为人们提供了all-in-one的数据处理方案。人们可以根据不同的场景使用spark生态圈的多个产品来解决应用，而不是使用多个隔离的系统来满足场景需求。下面是几个典型的例子：</p><ul><li><p>场景1：历史数据和实时数据分析查询</p><p>通过Spark进行历史数据分析、Spark Streaming进行实时数据分析，最后通过Spark SQL或BlinkDB给用户交互查询。</p></li><li><p>场景2：欺诈检测、异常行为的发现</p><p>通过Spark进行历史数据分析，用MLlib建立数据模型，对Spark Streaming实时数据进行评估，检测并发现异常数据。</p></li><li><p>场景3：社交网络洞察</p><p>通过Spark和GraphX计算社交关系，给出建议。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark介绍</title>
      <link href="/2019/04/25/Spark%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/04/25/Spark%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Spark简介"><a href="#Spark简介" class="headerlink" title="Spark简介"></a>Spark简介</h2><p>&emsp;&emsp;<strong>Spark</strong>是加州大学伯克利分校AMP实验室开发的通用内存并行计算框架。围绕着Spark推出了<strong>Spark SQL</strong>、<strong>Spark Streaming</strong>、<strong>MLLib</strong>、<strong>GraphX</strong>等组件，也就是BDAS（伯克利数据分析栈），这些组件逐渐形成大数据处理一站式解决平台。</p><p>&emsp;&emsp;<strong>Spark</strong>使用<strong>Scala</strong>语言实现，Scala 提供一个称为 <strong>Actor</strong> 的并行模型，其中Actor通过它的收件箱来发送和接收非同步信息而不是共享数据，该方式被称为：<strong>Shared Nothing</strong> 模型。它具有运行速度快、易用性好、通用性强和随处运行等特点。<br><a id="more"></a></p><h2 id="Spark和MR的区别"><a href="#Spark和MR的区别" class="headerlink" title="Spark和MR的区别"></a>Spark和MR的区别</h2><ol><li><strong>Spark</strong>把中间结果放到内存中，迭代运算效率高。<strong>MR</strong>中计算结果要落地，需要保存到磁盘上，这样会影响整体的速度。</li><li><strong>Spark</strong>容错性更高，它的弹性分布式数据集<strong>RDD</strong>可以通过血统进行重建。在RDD计算市，可以通过<strong>CheckPoint</strong>实现容错。</li><li><strong>Spark</strong>更加通用，提供了<strong>Transformations</strong>和<strong>Actions</strong>两类算子，不像MR只提供了Map和Reduce两种操作。同时，在各个节点间用户可以命名、物化、控制中间结果的存储、分区等。</li></ol><h2 id="Spark适用场景"><a href="#Spark适用场景" class="headerlink" title="Spark适用场景"></a>Spark适用场景</h2><h3 id="大数据处理场景"><a href="#大数据处理场景" class="headerlink" title="大数据处理场景"></a>大数据处理场景</h3><ol><li>复杂的<strong>批量处理</strong>（Batch Data Processing），偏重点在于处理海量数据的能力，至于处理速度可忍受，通常的时间可能是在数十分钟到数小时。</li><li>基于历史数据的<strong>交互式查询</strong>（Interactive Query），通常的时间在数十秒到数十分钟之间。</li><li>基于<strong>实时数据流</strong>的数据处理（Streaming Data Processing），通常在数百毫秒到数秒之间。</li></ol><h3 id="Spark场景"><a href="#Spark场景" class="headerlink" title="Spark场景"></a>Spark场景</h3><ol><li><strong>Spark</strong>是基于内存的迭代计算框架，适用于需要多次操作特定数据集的应用场合。需要反复操作的次数越多，所需读取的数据量越大，受益越大，数据量小但是计算密集度较大的场合，受益就相对较小。</li><li>由于RDD的特性，Spark不适用那种异步细粒度更新状态的应用，例如web服务的存储或者是增量的web爬虫和索引。就是对于那种增量修改的应用模型不适合。</li><li>数据量不是特别大，但是要求<strong>实时统计分析需求</strong>。</li></ol><h2 id="Spark案例"><a href="#Spark案例" class="headerlink" title="Spark案例"></a>Spark案例</h2><ol><li><p><strong>腾讯</strong></p><p>&emsp;&emsp;广点通是最早使用Spark的应用之一。腾讯大数据精准推荐借助Spark快速迭代的优势，围绕“数据+算法+系统”这套技术方案，实现了在“数据实时采集、算法实时训练、系统实时预测”的全流程实时并行高维算法，最终成功应用于广点通pCTR投放系统上，支持每天上百亿的请求量。</p><p>&emsp;&emsp;基于日志数据的快速查询系统业务构建于Spark之上的Shark，利用其快速查询以及内存表等优势，承担了日志数据的即席查询工作。在性能方面，普遍比Hive高2-10倍，如果使用内存表的功能，性能将会比Hive快百倍。</p></li><li><p><strong>Yahoo</strong></p><p>&emsp;&emsp;Yahoo将Spark用在Audience Expansion中的应用。Audience Expansion是广告中寻找目标用户的一种方法：首先广告者提供一些观看了广告并且购买产品的样本客户，据此进行学习，寻找更多可能转化的用户，对他们定向广告。Yahoo采用的算法是logistic regression。同时由于有些SQL负载需要更高的服务质量，又加入了专门跑Shark的大内存集群，用于取代商业BI/OLAP工具，承担报表/仪表盘和交互式/即席查询，同时与桌面BI工具对接。目前在Yahoo部署的Spark集群有112台节点，9.2TB内存。</p></li><li><p><strong>淘宝</strong></p><p>&emsp;&emsp;阿里搜索和广告业务，最初使用Mahout或者自己写的MR来解决复杂的机器学习，导致效率低而且代码不易维护。淘宝技术团队使用了Spark来解决多次迭代的机器学习算法、高计算复杂度的算法等。将Spark运用于淘宝的推荐相关算法上,同时还利用Graphx解决了许多生产问题，包括以下计算场景：基于度分布的中枢节点发现、基于最大连通图的社区发现、基于三角形计数的关系衡量、基于随机游走的用户属性传播等。</p></li><li><p><strong>优酷土豆</strong></p><p>&emsp;&emsp;优酷土豆在使用Hadoop集群的突出问题主要包括：第一是商业智能BI方面，分析师提交任务之后需要等待很久才得到结果；第二就是大数据量计算，比如进行一些模拟广告投放之时，计算量非常大的同时对效率要求也比较高，最后就是机器学习和图计算的迭代运算也是需要耗费大量资源且速度很慢。</p><p>&emsp;&emsp;最终发现这些应用场景并不适合在MapReduce里面去处理。通过对比，发现Spark性能比MapReduce提升很多。首先，交互查询响应快，性能比Hadoop提高若干倍；模拟广告投放计算效率高、延迟小（同hadoop比延迟至少降低一个数量级）；机器学习、图计算等迭代计算，大大减少了网络传输、数据落地等，极大的提高的计算性能。目前Spark已经广泛使用在优酷土豆的视频推荐（图计算）、广告业务等。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/2019/04/23/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/04/23/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;最近一段时间比较闲，想着搭个博客玩玩，看了网上主流的博客网站，不是太喜欢，作为一个互联网行业的小渣渣，博客当然要自己搭才有意思了，于是在网上找了一些方案，最终选择了<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>+<a href="https://github.com/" target="_blank" rel="noopener">github</a>的方式来搭建个人博客。</p><p><img src="https://i.loli.net/2019/04/28/5cc54dc5075b4.png" alt></p><a id="more"></a><p>&emsp;&emsp;使用<strong>github pages</strong>服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&emsp;&emsp;在你的博客之旅开始之前，首先要创建<strong>github</strong>账号，这个不做过多的介绍。登录你的github账户，创建一个名为<strong>你的用户名.github.io</strong>的仓库，将来你的博客访问地址就是这个啦。你也可以购买域名替换你的博客地址，当然这是要花钱的。</p><p>&emsp;&emsp;仓库建好后，我们需要在电脑上安装<strong>git</strong>和<strong>node.js</strong>，在这里要注意Git要提前配置好，和github做绑定，以后要用git工具将代码提交到github上保存的哦。<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a> 因为整个博客框架是基于node.js的，所以必须安装node.js环境，安装过程中一路Next即可。</p><h2 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架"></a>安装hexo框架</h2><p>&emsp;&emsp;准备工作做好后，我们就可以正式开始博客的搭建。<strong>Hexo</strong> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>&emsp;&emsp;在桌面鼠标右键，选择Git Bash Here，在弹出的Git命令窗口中输入安装命令，然后回车。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>​&emsp;&emsp;选择一个盘创建一个文件夹，在新建的文件夹内鼠标右键，选择Git Bash Here，输入初始化命令，然后回车，等命令执行完，就会看到生成了一系列的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着在该文件夹中继续执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;命令执行完后浏览器访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 或者 127.0.0.1:4000 ,就会看到hexo的初始界面，是不是有着一丝丝的成就感？但是，这个界面还是在本地，别人并不能看到，想要别人看到，我们就必须将这些文件部署到Github上去。</p><p>&emsp;&emsp;前面我们已经在github上创建好了博客仓库，接下来我们编辑博客文件夹下的<strong>_config.yml</strong>文件，在文件最后找到关键字<strong>deploy</strong>，对其进行编辑，其中<strong>repo</strong>后面的值要改成你的仓库地址，注意键值对之间要有空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/ocean233/ocean233.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;保存修改后，如果前面你的git已经可以推送文件到github上的话，你就可以直接执行以下命令将你的博客部署到GitHub上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是输入hexo d可能会报ERROR Deployer not fount： git错误，这是因为没有安装hexo-deployer-git这个模块，导致Git不能识别该命令，输入下面指令安装该模块即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;安装该模块会有些慢，因为Github毕竟是国外的网站，并不是很稳定，所以大家要耐心等待。安装失败时的话大家多试两遍。等模块安装完再次执行<strong>hexo d</strong>，这时就会有弹出框，输入自己之前注册的github账号进行登录，然后命令行也会要你输入对应的用户名并弹出输入框让你输入密码，填写完毕敲回车即可正确部署。</p><p>&emsp;&emsp;在浏览器输入<strong>你的用户名.github.io</strong>即可看到你自己搭建的博客了哦，如果上面的步骤都没问题，但是没有看到博客的话，可能是有些延迟，大家等等就好。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>&emsp;&emsp;搭建好的博客还很简单，博客样式说实话也是有点丑的，后面我们可以更换博客的主题，让博客更有特色。现在我们先来修改一下博客的基本配置吧。</p><p>&emsp;&emsp;对博客的配置修改主要是对配置文件<strong>_config.yml</strong>进行修改，我们现在的博客还很简单，所以能做的配置并不多，大家可以参考官网上的一些配置信息<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration</a> ，我也会列几个主要配置供大家参考。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Ocean&apos;s blog</span><br><span class="line">subtitle: 我的目标是星辰大海</span><br><span class="line">description: 大数据技术博客</span><br><span class="line">keywords:</span><br><span class="line">author: Ocean</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里大家可以修改博客的标题信息等，这是大家对博客进行定制化的第一步。</p><h2 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h2><p>&emsp;&emsp;我们搭建博客的主要目的自然是为了向大家分享我们的博客内容，绝对不是为了装B，所以如何写一篇文章才是我们应该关注的重点。</p><p>&emsp;&emsp;在你的博客文件夹目录下鼠标右键，点击Git Bash Here，接下来命令敲起来，新建一篇文章。如果没有设置 layout 的话，默认使用<strong>_config.yml</strong>中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这时候在/博客目录/source/posts目录下可以看到新建的博客文章，以.md结尾，在这里大家可以使用markdown语法编写自己的博客内容。</p><p><img src="https://i.loli.net/2019/04/28/5cc55d24c29d4.png" alt></p><p>&emsp;&emsp;博客内容写好后，回到命令行界面，敲命令将我们的博客内容部署到github上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果你想先看看编写的博客文章是怎样的，可以会用<strong>hexo s</strong>命令，在本地浏览器上先查看，没问题了再部署到github上。到这里，博客的基本操作你就已经熟悉了，可以开始玩转hexo了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2019/04/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/04/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p> &emsp;&emsp;最近都在和Linux打交道，我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢Linux的原因，比较短小但却功能强大。<br><a id="more"></a></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir test        创建文件夹</span><br><span class="line">rm -rf /test      删除文件夹</span><br><span class="line">cd /test          切换文件夹</span><br><span class="line">pwd               查看文件夹路径</span><br><span class="line">cp -r test /root  拷贝文件夹目录</span><br><span class="line">mv test /root     移动文件夹、更改文件夹的名字</span><br><span class="line">ls ll          查看文件夹下文件</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt    新建文件</span><br><span class="line">cp test.txt newtest.txt 复制文件</span><br><span class="line">rm -f test.txt    删除文件</span><br><span class="line">cat test.txt      查看文件内容</span><br><span class="line">more test.txt     分屏显示文件内容  空格键显示下一页内容，B键显示上一页内容，Q键退出</span><br><span class="line">head -10 test.txt 打印文件1-10行</span><br><span class="line">tail -10 test.txt 打印最后10行内容</span><br><span class="line">tail -f test.txt  实时打印文件内容</span><br><span class="line">find 路径 -name test.txt 查找文件或目录，列出路径，可以使用正则表达式查找</span><br></pre></td></tr></table></figure><h2 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi/vim"></a>vi/vim</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">命令行模式 </span><br><span class="line">:w保存  </span><br><span class="line">:q退出  </span><br><span class="line">:q!不保存强制退出  </span><br><span class="line">:set nu显示行号 </span><br><span class="line">:/单词查找匹配</span><br><span class="line">:N,Md 删除N-M行数据</span><br><span class="line">一般模式：   </span><br><span class="line">yy复制当前行 </span><br><span class="line">    nyy复制下面n行 </span><br><span class="line">    p粘贴到下一行 P粘贴到上一行</span><br><span class="line">G移动到最后一行</span><br><span class="line">nG移动到第n行</span><br><span class="line">n+光标下移n行 </span><br><span class="line">    n-光标上移n行 </span><br><span class="line">H光标移动到屏幕顶行 </span><br><span class="line">    M光标移动到屏幕中间行 </span><br><span class="line">    L光标移动到屏幕最后行</span><br><span class="line">dd删除行   </span><br><span class="line">x删除光标后一个字符 X删除光标前一个字符 </span><br><span class="line">u恢复前一个动作</span><br></pre></td></tr></table></figure><h2 id="远程拷贝"><a href="#远程拷贝" class="headerlink" title="远程拷贝"></a>远程拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp [-r] test.txt root@node02:`pwd`   本地到远程</span><br><span class="line">scp [-r] root@node02:/test /root/     远程到本地</span><br></pre></td></tr></table></figure><h2 id="磁盘指令"><a href="#磁盘指令" class="headerlink" title="磁盘指令"></a>磁盘指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df [-m][-k][-h]      查看硬盘信息</span><br><span class="line">du [-k][-m][-a][-h][-max-depth=0] /目录    查看目录信息</span><br></pre></td></tr></table></figure><h2 id="网络指令"><a href="#网络指令" class="headerlink" title="网络指令"></a>网络指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifconfig                          查看网络配置</span><br><span class="line">ping ip地址                        查看是否连通</span><br><span class="line">netstat                           查看网络相关信息</span><br><span class="line">telnet 192.168.198.111 22         测试远程主机网络端口  Ctrl+]   输入q退出</span><br><span class="line">curl -X GET http://www.baidu.com/ http请求模拟</span><br></pre></td></tr></table></figure><p>​          </p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">*用户操作指令：</span><br><span class="line">useradd ocean     添加用户，创建一个组</span><br><span class="line">passwd ocean      修改密码</span><br><span class="line">useradd -r ocean  删除用户</span><br><span class="line">usermod -l newocean ocean 修改用户名</span><br><span class="line">usermod -L ocean  锁定账号</span><br><span class="line">usermod -U ocean  解锁账号</span><br><span class="line">/etc/passwd   /etc/shodow    查看用户</span><br><span class="line">*用户组操作指令：</span><br><span class="line">groupadd groupname创建用户组</span><br><span class="line">groupdel groupname删除用户组</span><br><span class="line">groupmod -n newname name 修改用户组名</span><br><span class="line">groups   查看当前登录用户的组内成员</span><br><span class="line">groups ocean   查看指定用户所在组</span><br><span class="line">usermod [-g][-G] 组名 用户   修改用户的主组或者附加组</span><br><span class="line">cat /etc/group 查看组</span><br><span class="line"></span><br><span class="line">*文件权限：</span><br><span class="line">UGO模型：USER  GROUP  OTHER</span><br><span class="line">chown -R user:group 目录名字   修改整个目录下的所有者和属组</span><br><span class="line">chmod ugo+rwx test.txt  修改文件的权限</span><br><span class="line">chmod 700 test.txt  设置权限</span><br><span class="line"></span><br><span class="line">*系统服务初始化配置：</span><br><span class="line">0：停机状态</span><br><span class="line">1：单用户模式</span><br><span class="line">2：多用户</span><br><span class="line">3：完全多用户</span><br><span class="line">4：为定义</span><br><span class="line">5：图形化</span><br><span class="line">6：停止所有进程，重启</span><br><span class="line"></span><br><span class="line">*系统时间指令：</span><br><span class="line">date 查看时间</span><br><span class="line">date -s 时间  修改时间</span><br><span class="line">时间同步：</span><br><span class="line">yum -y install ntp</span><br><span class="line">ntpdate cn.ntp.org.cn</span><br><span class="line"></span><br><span class="line">*配置主机名：   </span><br><span class="line">vim /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line">*配置域名映射： </span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">*sudo权限配置： </span><br><span class="line">vim /etc/sudoers</span><br><span class="line">sudo -l</span><br><span class="line"></span><br><span class="line">*环境变量：</span><br><span class="line">vim /etc/profile   全局</span><br><span class="line">echo $path  显示环境变量</span><br><span class="line">source /etc/profile  重新加载环境变量</span><br><span class="line">vi  ~/.bash_profile  临时</span><br><span class="line">  </span><br><span class="line">*防火墙：</span><br><span class="line">service iptables status查看状态</span><br><span class="line">    chkconfig iptables on/off 永久生效</span><br><span class="line">    service iptables start 即时生效</span><br></pre></td></tr></table></figure><h2 id="重定向和管道"><a href="#重定向和管道" class="headerlink" title="重定向和管道"></a>重定向和管道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输出重定向：&gt;    &gt;&gt;</span><br><span class="line">输入重定向：&lt;    &lt;&lt;</span><br><span class="line">标准输出重定向：  1&gt;</span><br><span class="line">错误输出重定向：  2&gt;</span><br><span class="line">结合使用：2&gt;&amp;1</span><br><span class="line">管道： |</span><br><span class="line">命令执行控制：&amp;&amp; 前一个命令执行成功才会执行后一个命令</span><br><span class="line">|| 前一个命令执行失败才会执行后一个命令</span><br><span class="line">信息黑洞：/dev/null</span><br></pre></td></tr></table></figure><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">定义变量：name=&quot;ocean&quot;</span><br><span class="line">引用变量：$name</span><br><span class="line">数组：my_array=&#123;A,B,C,D&#125;        $&#123;my_array[0]&#125;</span><br><span class="line">运算符：</span><br><span class="line">表达式和运算符之间必须有空格</span><br><span class="line">完整的表达式要被 ` ` 包含</span><br><span class="line">val=`expr $a + $b` </span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">val=`expr $a \* $b` </span><br><span class="line">val=`expr $b / $a` </span><br><span class="line">val=`expr $b % $a`</span><br><span class="line">$a == $b</span><br><span class="line">$a != $b</span><br><span class="line">-eq是否相等   -ne是否不相等   -gt左边是否大于右边   -lt左边是否小于右边    -ge左边是大于等于右边    -le左边是否小于等于右边</span><br><span class="line">&amp;&amp;   ||</span><br><span class="line">=字符串是否相等   !=是否不想等   -z长度是否为0   -n长度是否不为0    str是否为不为空</span><br><span class="line">流程控制</span><br><span class="line">函数test()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="服务指令"><a href="#服务指令" class="headerlink" title="服务指令"></a>服务指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">列出所有服务   chkconfig   </span><br><span class="line">service 服务名  start/stop/status/restart</span><br><span class="line">添加服务   /etc/init.d系统各种服务的启动和停止脚本</span><br><span class="line"> /etc/rc.d/ 系统对应执行级别的服务软连接</span><br><span class="line">步骤：在脚本中添加两行代码#chkconfig: 2345 80 90 #description:auto_run </span><br><span class="line"> 编写脚本</span><br><span class="line"> 修改可执行权限</span><br><span class="line"> 将脚本拷贝到/etc/init.d目录下</span><br><span class="line"> 加入到服务里chkconfig --add test.sh</span><br><span class="line"> 重启服务器</span><br><span class="line">删除服务：chkconfig --del name</span><br><span class="line">服务等级更改：chkconfig --level 2345 name off|on   默认是2345</span><br></pre></td></tr></table></figure><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minute hour day month dayofweek 命令</span><br><span class="line">查看定时任务：/var/spool/mail  目录下放各用户定时任务，执行后的信息</span><br><span class="line">/var/spool/cron 目录存放每个用户的定时任务</span><br><span class="line">contab –l 可以直接查看当前用户的定时任务</span><br></pre></td></tr></table></figure><h2 id="linux安全"><a href="#linux安全" class="headerlink" title="linux安全"></a>linux安全</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selinux  enforcing强制模式</span><br><span class="line"> permissive宽容模式</span><br><span class="line"> disabled关闭</span><br><span class="line">sestatus -v查看状态</span><br></pre></td></tr></table></figure><h2 id="linux进程"><a href="#linux进程" class="headerlink" title="linux进程"></a>linux进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -aux查看进程   jobs -l</span><br><span class="line">ps -ef | grep ssh查看相关进程</span><br><span class="line">ps -aux --sort -pcpu根据CPU使用来升序排列</span><br><span class="line">top性能分析</span><br><span class="line">nohup /root/start.h &amp;  后台运行</span><br><span class="line">kill -9 杀死进程</span><br></pre></td></tr></table></figure><h2 id="解压压缩下载"><a href="#解压压缩下载" class="headerlink" title="解压压缩下载"></a>解压压缩下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum下载</span><br><span class="line">wget下载</span><br><span class="line">RPM命令：rpm  –ivh  rpm包  安装</span><br><span class="line">rpm -q ntp        查找</span><br><span class="line">rpm –e 包名       卸载</span><br><span class="line">tar命令：tar  -zvxf  xxxx.tar.gz       解压</span><br><span class="line">tar -zcf 压缩包命名 压缩目标  压缩</span><br><span class="line">zip命令：zip -r 包名 目标目录    压缩</span><br><span class="line">unzip filename          解压</span><br></pre></td></tr></table></figure><p>​<br>​<br>​              </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
